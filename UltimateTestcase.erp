**moduleDeclarations**

DECLARE MODULE module1;
DECLARE MODULE module2;
DECLARE MODULE module3;



**otherModules**

<<MODULE module1>>
TAKES INPUT[ip1:INTEGER, ip2:REAL, ip3:ARRAY[0..9999] OF INTEGER, ip4:BOOLEAN, ip768:ARRAY[id1..7] OF REAL, ip689:ARRAY[7..id9] OF REAL];
RETURNS [ip4:REAL, ip2:INTEGER, ip1001: BOOLEAN];

START
**insert some statements here**
END


<<MODULE module2>>
TAKES INPUT[ip1:INTEGER, ip2:REAL, ip3:ARRAY[0..9999] OF INTEGER, ip4:BOOLEAN, ip768:ARRAY[id1..7] OF REAL, ip689:ARRAY[7..id9] OF REAL];
RETURNS [ip4:REAL, ip2:INTEGER, ip1001: BOOLEAN];

START
**insert some statements here**
END





**driverModule**

<<<DRIVER PROGRAM>>>
START


	**IO Statements**
		
		GET_VALUE(id1);
		PRINT(arr1[34]);
		PRINT(arr1[arr2]);
		PRINT(34);
		PRINT(34.23);
		PRINT(arr1);
		PRINT(TRUE);
		PRINT(FALSE);

	**END OF IO Statements**



	**Iterative Statements**
		
		FOR(id1 in 3..5)
			START

			END

		WHILE(a+b <(b-c) AND c/d > (d*e) OR (TRUE) AND ((c-d)*23.46e-10)+arr[10])

		**The statement enclosed in brackets in WHILE is a valid arithOrBoolExpr**

			START

			END

		WHILE((TRUE))
		START 
		END

	**END OF Iterative Statements**


	**Simple Statements: Assignment & moduleReuse**

	**Assignment Statements**

		arithOrBoolVar :=a+b <(b-c) AND c/d > (d*e) OR (TRUE) AND ((c-d)*23.46e-10)+arr[10];
		
		arithVar:=+((a+b));
		arithVar:=+(FALSE);
		arithVar:=FALSE; **should be syntax error**
		arithVar:=a+b;
		arithVar:=(a+b);
		arithVar:=(a/b);
		arithVar:=a/b;
		arithVar:=arr1[arr2];
		arithVar:=arr1[35];
		arithVar:=arr1;
		arithVar:=37;
		arithVar:=232.23223;


		id3:=arr4[arr5];
		id4:=arr5;
		id5:=arr4[35];
		id6:=34.543;
		id7:=44;

		arr1[id1]:=a+b <(b-c) AND c/d > (d*e) OR (TRUE) AND ((c-d)*23.46e-10)+arr[10];
		arr2[id2]:=+((a+b));
		arr1[id3]:=arr4[arr5];
		arr1[id4]:=arr5;
		arr2[id5]:=arr4[35];
		arr1[id6]:=34.543;
		arr2[id7]:=44;

	**END OF Assignment Statements**

	**Module Reuse Statements**
		[id1,id2,id3] USE MODULE module1 WITH PARAMETERS [id4,id5,id6];
	**END OF Module Reuse Statements**



	**Declare Statements**
		DECLARE id1,id2,id3: INTEGER;
		DECLARE id3,id4,id5: ARRAY[arr1..arr2] OF REAL;
		DECLARE id6,id7,id8: ARRAy[arr1..7] OF INTEGER;
		DECLARE id6,id7,id8: ARRAy[9..arr2] OF INTEGER;
		DECLARE id6,id7,id8: ARRAy[9..7] OF INTEGER;

	**END OF Declare Statements**



	**Conditional Statements**
		SWITCH(id1)
		START
			CASE(35):
				**insert some statements here*
			BREAK;

			CASE(TRUE):
				**insert some statements here**
			BREAK;

			DEFAULT:
				**insert some statements here*
			BREAK;
		END
	**END OF Conditional Statements**




END


**otherModules**

<<MODULE module1>>
TAKES INPUT[ip1:INTEGER, ip2:REAL, ip3:ARRAY[0..9999] OF INTEGER, ip4:BOOLEAN, ip768:ARRAY[id1..7] OF REAL, ip689:ARRAY[7..id9] OF REAL];
RETURNS [ip4:REAL, ip2:INTEGER, ip1001: BOOLEAN];

START
**insert some statements here**
END

<<MODULE module2>>
TAKES INPUT[ip1:INTEGER, ip2:REAL, ip3:ARRAY[0..9999] OF INTEGER, ip4:BOOLEAN, ip768:ARRAY[id1..7] OF REAL, ip689:ARRAY[7..id9] OF REAL];
RETURNS [ip4:REAL, ip2:INTEGER, ip1001: BOOLEAN];

START
**insert some statements here**
END

