/**
 * This is a blueprint pseudo code representation of how the AST will
 * be traversed for code generation. After the blueprint is ready, the 
 * pseudo code can be translated into C code. 
 */

This might be helpful: https://www.cs.uaf.edu/2005/fall/cs301/support/x86/nasm.html

To compile nasm programs:
    nasm -f elf <file_name>.asm
To link files using gcc (on 64 bits systems) (Requires global main):
    gcc -m32 <file_name>.o -o <file_name>

To link files using gcc (on 32 bits systems) (Requires global main):
    gcc <file_name>.o -o <file_name>    

To link files using ld (Requires global _start):
    ld -m elf_i386 <file_name>.o -o <out_file_name>

To run the compiled program:    
./<out_file_name>

/* ---- Sample NASM program ---- */
section .data
msg	db	'Hello world!',0Ah;
section .text
global main:     ; _start when linking with ld

main:
	mov	edx, 13  ;number of bytes to write
	mov ecx, msg ;move memory address of our message string
	mov ebx, 1	 ;write to stdout
	mov eax, 4	 ;marshal system write system call opcode into eax
	int 80h		 ;generate interrupt    
	
	mov	ebx, 0	 ;return 0 status on exit - 'No errors'
	mov eax, 1	 ;invoke SYS_EXIT system call (kernel opcode 1)
	int 80h		 ;generate interrupt

/* --------------------------- */

/* ---- A standard way to setup stack frames [makes debugging easy] ---- */
https://stackoverflow.com/questions/17239781/x86-assembly-why-do-i-need-stack-frames
/* Saves the pointer to the base of current stack frame, and moves stack pointer to 
    ebx. Thus we are free to use stack inside the called function */

    /*setting the stack frame*/
        push    ebp     
        mov     ebp,esp

        ...
        code goes here
        ...

        /*removing the stack frame*/
        mov     esp, ebp
        pop     ebp 
/* ---------------------------------------------------------------------- */


traverseAST(): {
    switch on type pf AST node: {
        AST_NODE_PROGRAM:  {
            /* init text and data section here */
            ----
            section .data
            ;define all the global variables here 
            section .text
            global main ;NOTE: In case you are linking with ld, use _start. Use main when linking with gcc
            ----
        }
        AST_NODE_MODULEDECLARATION: {
            /* Helps only in construction of symbol table */
        }
        AST_NODE_MODULELIST: {
            /* Helps in AST traversal */
        }
        AST_NODE_MODULE: {
            /* start module definition. Get SymbolTableFunc for this module 
                It is assumed that the caller has pushed the relevant arguments into the stack, and has pushed 
                the address of the arguments at the end. Also, ebp points to the start of the stack frame */
            ----
            %module_name:
            ----
            /* Everything can be accessed in the stack frame */
                ----
                ;Do stuff
                ----    
        }
        AST_NODE_INPUTLIST: {
            /* Helps only in construction of symbol table */
        }
        AST_NODE_OUTPUTLIST: {
            /* Helps only in construction of symbol table */
        }
        AST_NODE_ARRAY: {
            /* TODO */
        }
        AST_NODE_RANGEARRAYS:
        AST_NODE_STATEMENT: {
            
            if child is NULL
                if these block of statements belong to a moduleDef:
                    ---
                    ret
                    ---

        }
        AST_NODE_IO: {
            /* Fetch the variable from the symbol table on which the I/O is called */

            if get_val:
                /* Get value is on ID. That means we cant get value into an array type. 
                   Get the variable from symbol table. It must have an offset. */
                ----
                mov     edx, ID.width           ; number of bytes to read
                mov     ecx, [ebp + offset]     ; reserved space to store the input
                mov     ebx, 0                  ; write to stdin
                mov     eax, 3                  ; invoke SYS_READ (kernel opcode 3)
                int     80h                     ; interrupt, switch context to kernel
                ----

            else if put_val:
                /* Put value is on var
                    var -> var_id_num
                    var_id_num -> ID, ID[index], NUM, RNUM */
                if ID:
                    /* Get the symbol table entry for ID and its offset */
                    ----
                    mov	edx, ID.width   ;number of bytes to write
                    mov ecx, [ebp + offset]       ;move memory address of the value
                    ----
                else if ID[index]:
                    ----
                    mov edx, ID.width
                    mov ecx, [ebp + offset + index]
                    ----
                else:
                    /* not sure what to do here */
                    ----
                    mov edx, NUM.width | RNUM.width
                    mov ecx, NUM | RNUM
                    ----

                ----
                mov ebx, 1	        ;write to stdout
                mov eax, 4	        ;marshal system write system call opcode into eax
                int 80h		        ;generate interrupt    
                ----  
        }
        AST_NODE_SIMPLESTMT: {
            /* Just traverse */
        }
        AST_NODE_ASSIGN: {
            /* Traverse first. This will assume that rhs will have values stored in stack */
            ch = curr->child
            ch = ch->next;
            traverseAST(ch, fname);
            ----
            pop ax
            mov [ebp + <lhs>.offset], ax
            ----
        }
        AST_NODE_MODULEREUSE: {
            /* Setting the stack frame. */

            /* Get symbolTableFunc for the called module. */

            ----
            ;Save the current stack frame pointer
            pusha   ;ebp          
            ;Move the current pointer to stack as the base of the called function.
            ;This makes sure that we are free to stack pointer now 
            mov     ebp,esp 
            ----     
            
            /* Iterate through output_plist, and reserve that much space at 
                the base of the stack frame */
            
            actRecSize = sum of width of output_plist + input_plist + local variables + temporary variables

            ----
            add esp, actRecSize
            ----


            /* Iterate in through args list, and assign them values at their offsets in the frame */
            for each <arg> in modulereuse.args and corresponsing <input_param> in input_plist:
                ----
                mov ax, <arg>.value
                mov [ebp + <input_param>.offset], ax 
                ----

            /* call the function */

            ----
            call %name_of_module
            ----

            /* removing the stack frame */
            ----
            mov     esp, ebp
            popa    ; ebp
            ----

            /* Store the output.
                We can do this by iterating through the output_plist */
            
            for each <output_param> in the output_plist:
                ----
                mov ax, [esp + (memory_organisation)*8 + <output_param>.offset] ; take care of byte org/word org
                mov [ebp + <left_arg>.offset], ax    
                ----

                <left_Arg> = <left_arg>.next;

        }
        AST_NODE_IDLIST:
        AST_NODE_EXPR:
        AST_NODE_AOBEXPR: {
            x = a + c - d / e;
            

            a + AOB (t2)
                c - AOB (t1) <--
                    d / num
        when leaf:
            mov EAX, [d]
            mov EBX, NUM
            DIV EAX, EBX
            MOV [t1], EAX
            /// repeat
        when non-leaf:
            get t1
            mov ax, [t1]
            mov bx, [c] 
            sub ax, bx
            mov [t2], ax   
        }
        AST_NODE_DECLARESTMT:
        AST_NODE_CONDSTMT:
        AST_NODE_CASESTMT:
        AST_NODE_UNARY:
        AST_NODE_LVALARRSTMT:
        AST_NODE_ITERSTMT:
        AST_NODE_VARIDNUM:
        AST_NODE_LEAF: {
            switch on leaf type: {
                AST_LEAF_INT:
                AST_LEAF_RNUM:
                AST_LEAF_BOOL:
                AST_LEAF_ID: {
                    switch on parent type {
                        AST_NODE_MODULEDECLARATION:
                        AST_NODE_MODULE:
                        AST_NODE_INPUTLIST:
                        AST_NODE_OUTPUTLIST:
                        AST_NODE_IO:
                        AST_NODE_VARIDNUM:
                        AST_NODE_LVALARRSTMT:
                        AST_NODE_ASSIGN:
                        AST_NODE_MODULEREUSE: {
                            
                        }
                        AST_NODE_IDLIST: {
                            /* Only for AST iteration */
                        }
                        AST_NODE_CONDSTMT: {

                        }
                        AST_NODE_ITERSTMT:
                    }
                }
                AST_LEAF_NUM:
                AST_LEAF_IDXNUM:
                AST_LEAF_IDXID:
                AST_LEAF_PLUS:
                AST_LEAF_MINUS:
                AST_LEAF_MUL:
                AST_LEAF_DIV:
                AST_LEAF_OR:
                AST_LEAF_AND:
                AST_LEAF_LT:
                AST_LEAF_LE:
                AST_LEAF_GT:
                AST_LEAF_GE:
                AST_LEAF_EQ:
                AST_LEAF_NE:
                AST_LEAF_TRUE:
                AST_LEAF_FALSE:
                AST_LEAF_VALNUM:
                AST_LEAF_VALTRUE:
                AST_LEAF_VALFALSE:
                AST_LEAF_VARIDNUM_NUM:
                AST_LEAF_VARIDNUM_ID:
                AST_LEAF_VARIDNUM_RNUM:
                AST_LEAF_BOOLTRUE:
                AST_LEAF_BOOLFALSE:
                AST_LEAF_UOPPLUS:
                AST_LEAF_UOPMINUS:
                default:
            }

        }
    }
}
